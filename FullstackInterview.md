## _Вопрос 1_
>Читали ли вы чужой код? Если да, то что это был за код? Опишите свои впечатления от него.

Приходилось работать на нескольких проектах. Объединяло их только использование ASP.NET.
От серверной части впечатления всегда были хорошие, т.к. ASP.NET стандартизирует архитектуру, а язык C# стимулирует написание лаконичного кода.
То же самое нельзя сказать про фронтенд проекта с легаси на JS: доработка большого объёма кода на ванильном JS — задача наисложнейшая из-за отсутствия статической типизации.
Именно поэтому мне понравились проекты с современными фреймворками: React, Angular. В обоих проектах использовался TypeScript, упрощающий написание корректного кода многократно.
Также мне понравилось, что эти фреймворки унифицируют архитектуру и делают её более интуитивной, что упрощает адаптацию нового разработчика на проекте.

## _Вопрос 2_
>Опишите известные вам языки программирования и их предназначение.

**C** — разработка низкоуровневого ПО (ОС, драйвера, микроконтроллеры), а также программ и модулей, в которых важна производительность. Минимальный набор абстракций делает этот язык приближенным по производительности к ассемблеру, но в то же время несложным для написания кода.

**С++** — разработка высокопроизводительных приложений, преимущественно desktop (Qt, MFC). Поддержка ООП и богатый выбор библиотек позволяют легко писать большие и быстрые программы.

**C#, Java** — языки-последователи C++, созданные для быстрой разработки больших и легко масштабируемых приложений. В них убраны многие спорные возможности C++, например множественное наследование и макросы, а управление памятью производится сборщиком мусора. Java более консервативна, в то время как в C# сравнительно много нововведений (Linq, методы расширения, Pattern Matching). 

**Python** — скриптовый язык с лаконичным синтаксисом и динамической типизацией, подходящий для простого и быстрого написания небольших программ. Используется в вебе и в математических расчётах.

**Ruby** — простой скриптовый язык. Используется преимущественно в вебе (Ruby on Rails). Также на нём написан Homebrew — менеджер пакетов для Mac OS.

**PHP** — скриптовый язык для веба.

**JavaScript** — скриптовый язык, на котором пишется вся клиентская часть кода в вебе. С появлением Node.js стал использоваться для более общих задач, вплоть до написания desktop-приложений. Имеет различные синтаксические расширения: TypeScript, Flow, CoffeeScript, Dart.

**Go** — простой и быстрый язык со статической типизацией. Широкие возможности многопоточности, встроенные на уровне синтаксиса, делают его идеальным выбором для написания высоконагруженных веб-сервисов.

**Scala** — изящный функциональный язык с богатой системой типов, работающий на виртуальной машине Java. Применяется в написании веб-сервисов и в обработке больших данных (фреймворк Spark).

**Swift** — современный язык для разработки под продукты компании Apple.

**Kotlin** — более современный аналог Java, работающий на её виртуальной машине. Применяется для тех же задач.

## _Вопрос 3_
>Что такое “компилятор“, зачем он нужен и почему некоторые языки обходятся без него?

Компилятор — программа для перевода кода на высокоуровневом языке в исполняемые файлы в двоичном коде. В более общем значении — программа, переводящая один язык в другой (например, TypeScript компилируется в JavaScript).

Некоторые языки не переводятся в двоичный код, а исполняются программой-интерпретатором.

## _Вопрос 4_
>Что такое “фреймворк” и для чего он нужен? Приведите примеры известных вам фреймворков.

Фреймворк — программный модуль, определяющий основную структуру и порядок выполнения программы. В отличие от библиотеки, фреймворк, как правило, вызывает написанные пользователем модули, а не наоборот (инверсия управления).

Примеры фреймворков: ASP.NET MVC, React, Angular.

## _Вопрос 5_
>Что за приставка “http://” перед адресами сайтов и почему она всё чаще теперь становится
“https://“?

HTTP — клиент-серверный протокол передачи данных, по которому клиент отсылает серверу веб-запрос и получает от него веб-ответ.
Веб-запрос соответствует одному из HTTP-методов: GET, POST, PUT, DELETE.
Веб-ответ содержит код состояния HTTP: 2xx — успешно, 3xx — перенаправление, 4xx — ошибка со стороны клиента, 5xx — внутренняя ошибка сервера.

HTTPS — расширение HTTP, при котором передаваемые между клиентом и сервером сообщения шифруются, чтобы их не могли перехватить третьи лица.

## _Вопрос 6_
>Самая популярная библиотека для разработки фронтенд-приложений, ReactJS, моделирует
>логику в виде компонентов.
>Если бы вам нужно было на ReactJS разработать страницу профиля ВКонтакте
>(например, https://vk.com/id1), на какие компоненты вы бы её разбили? Почему именно так?

Первым делом я бы разделил всю страницу на компонент Header (заголовок с поиском/регистрацией/плеером) и Content (всё остальное).
Затем в Content я бы выделил компонент ProfileContent — неподвижный при скролле блок с аватаром, фотоальбомами и аудиозаписями профиля. Его, соответственно, следует разбить на компоненты Avatar, Albums, Audio, т.к. они отделены информационно и визуально.
По левую сторону от него расположен весьма простой блок — вход либо навигация — обозначу его Sidebar.
Справа основной блок, который я назову MainProfileContent. Он состоит из информации профиля, фотоальбомов и записей: компоненты ProfileInfo, Photos, Wall.
Wall включает в себя набор записей, единичную запись назову WallRecord. Она содержит само содержимое записи c количеством лайков, репостов и просмотров, а также компонент Comments, который разумно будет разбить на компонент CommentList со списком комментариев и CommentField с текстовым полем и кнопкой отправки. Комментарий в CommentList Обозначу компонентом Comment, состоящим из имени и аватара отправителя, текста, даты и числа лайков.

Принцип разбиения основан на том, что вся страница — это композиция компонентов: более сложные компоненты состоят из множества более простых. Компоненты по общим критериям объединяются, оборачиваясь общим компонентом.

## _Вопрос 7_
>SqlServer, PostgreSQL, SQLLite, MySQL, Oracle, Microsoft Access - разные базы данных с разным
>функционалом, которые разрабатываются, в основном, разными компаниями с разным
>видением своего продукта.
>Однако все эти базы используют один и тот же язык запросов - SQL, и не планируют от него
>отказываться. Как так получается? Что такого в SQL, что он подходит всем этим базам?
>А если он такой чудесный, то почему многие другие базы данных, вроде MongoDB или Cassandra,
>его не используют?

Разные языки существуют для разных задач. SQL, основанный на реляционной алгебре, предусматривает практически все задачи, которые могут возникнуть в объединении и отображении данных из реляционной базы (т.е. описывающей отношения между моделями данных). В других языках нет необходимости, унификация даёт преимущества, т.к. программисту не составит сложности написать запрос, если, например, в проекте заменили MS SQL на Postgres. Хотя, тем не менее, существуют разные диалекты (например T-SQL).

Существуют также нереляционные БД (NoSQL). Они созданы для иных задач: большие данные, иерархически организованные данные и т.д. Как правило, это хранилища, преимущество которых в большей скорости и возможности горизонтального масштабирования (повышения производительности распределённой БД засчёт увеличения числа серверов, чтобы сократить нагрузку). Обычно у них нет предопределённой схемы. SQL в них не используется.

## _Вопрос 8_
>Пришлите ссылку на пример вашего кода на C#, за который вам не стыдно. Если кода нет,
выполните задание ниже. Оно также поможет, если код есть.

Собственно, задача: https://github.com/yn1046/Shapes

Также нестыдно показать это (сервис-имитация фондовых бирж): https://github.com/yn1046/ExchangeApi

## _Вопрос 9_
>В базе данных MS SQL Server есть продукты и категории. Одному продукту может
>соответствовать много категорий, в одной категории может быть много продуктов.
>Напишите SQL запрос для выбора всех пар «Имя продукта – Имя категории». Если у продукта
>нет категорий, то его имя все равно должно выводиться.

Это отношение "N к N", так что в целях нормализации добавим таблицу, соединяющую продукты и категории.
Итого имеем три таблицы: Products, Categories, ProductCategories.

```sql
CREATE TABLE Products (
  Id int PRIMARY KEY,
  Name nvarchar(50) NOT NULL,
  Price int NOT NULL
);

CREATE TABLE Categories (
  Id int PRIMARY KEY,
  Name nvarchar(50) NOT NULL
);

CREATE TABLE ProductCategories (
  Id int PRIMARY KEY,
  ProductId int NOT NULL,
  CategoryId int NOT NULL,
  FOREIGN KEY (ProductId) REFERENCES Products(Id),
  FOREIGN KEY (CategoryId) REFERENCES Categories(Id)
);
```

Заполним данными:

```sql
INSERT INTO Products VALUES
(1, 'Банан', 35),
(2, 'Апельсин', 50),
(3, 'Хлеб', 20),
(4, 'Огнемёт', 1500);

INSERT INTO Categories VALUES
(1, 'Еда'),
(2, 'Фрукт');

INSERT INTO ProductCategories VALUES
(1,1, 1),
(2,1,2),
(3,2,1),
(4,2,2),
(5,3,1)
```

Теперь напишем запрос. Чтобы из одной таблицы были выбраны все записи вне зависимости от наличия соответствия в другой, используется Left outer join:

```sql
SELECT P.Name AS 'Product Name', C.Name AS 'Category Name' FROM Products P
LEFT JOIN ProductCategories CP ON CP.ProductId = P.Id
LEFT JOIN Categories C ON CP.CategoryId = C.Id
```
